<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="/jekyll-theme-yat/feed.xml" rel="self" type="application/atom+xml" /><link href="/jekyll-theme-yat/" rel="alternate" type="text/html" /><updated>2023-03-22T17:20:12+00:00</updated><id>/jekyll-theme-yat/feed.xml</id><title type="html">JUNGHOO 블로그</title><subtitle>하루하루 열심히 살아가고픈 Junghoo의 블로그</subtitle><author><name>Junghoo</name></author><entry><title type="html">프로그래밍 패러다임</title><link href="/jekyll-theme-yat/cs/2023/03/22/post20.html" rel="alternate" type="text/html" title="프로그래밍 패러다임" /><published>2023-03-22T00:00:00+00:00</published><updated>2023-03-22T00:00:00+00:00</updated><id>/jekyll-theme-yat/cs/2023/03/22/post20</id><content type="html" xml:base="/jekyll-theme-yat/cs/2023/03/22/post20.html"><![CDATA[<h3 id="프로그래밍-패러다임이란">프로그래밍 패러다임이란?</h3>

<blockquote style="margin: 1rem 0px 5rem;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1rem 1rem 1rem 2rem;
    color: #ECECEC;">
  <p style="margin: 0;">프로그래머에게 프로그래밍의 관점을 갖게 해주는 역할을 하는 개발 방법론입니다.</p>
</blockquote>

<h3 id="프로그래밍-패러다임의-분류">프로그래밍 패러다임의 분류</h3>

<div style="text-align: center; width: 534px;">
  <img style="margin: 3rem auto 2.5rem;" width="534" src="https://user-images.githubusercontent.com/76745621/226969120-e53ed8bf-3db2-4e93-9702-6e2382f245a6.png" alt="싱글톤 패턴 예시 이미지" />
  <br />
  <span style="font-weight: bold">이미지 출저 -</span>
  <a style="color: dodgerblue" href="https://velog.io/@younoah/programming-paradigm" target="_blank" rel="noopener noreferrer">https://velog.io/@younoah/programming-paradigm</a>
</div>
<blockquote style="margin: 3rem 0px 7rem;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1.5rem 1rem 1rem 2rem;
    color: #ECECEC;">
  <p style="margin: 0.25rem 0;">프로그래밍 패러다임은 위 이미지처럼 크게 선언형, 명령형으로 나뉩니다.</p>
  <br />
  <p style="margin: 0.25rem 0;">선언형 프로그래밍의 대표적인 예시 -  함수형 프로그래밍</p>
  <p style="margin: 0.25rem 0;">명령형 프로그래밍의 대표적인 예시 - 객체지향 프로그래밍, 절차형 프로그래밍</p>
  <br />
  <!-- <p style='margin: 0.25rem 0;'>선언형 프로그래밍</p>
  <p style='margin: 0.25rem 0;'>- '프로그램은 함수로 이루어진 것이다.' 라는 명제가 담겨 있는 무엇을 풀어내는가에 집중하는 패러다임입니다.</p>
  <br /> -->
  <br /><br />
  <p style="margin: 0.25rem 0;">함수형 프로그래밍</p>
  <p style="margin: 0.25rem 0;">- 선언형 프로그래밍의 일종으로 '순수 함수'들을 블록처럼 쌓아 로직을 구현하고 '고차 함수'를 통해 재사용성을 높인 프로그래밍 패러다임입니다.</p>
  <br /><br />
  <p style="margin: 0.25rem 0;">객체지향 프로그래밍</p>
  <p style="margin: 0.25rem 0;">- 객체들의 집합으로 프로그램의 상호 작용을 표현하며 데이터를 객체로 취급하여 객체 내부에 선언된 메서드를 활용하는 방식입니다.</p>
  <p style="margin: 0.25rem 0;">- 설계에 많은 시간이 소요되며 처리 속도가 다른 프로그래밍 패러다임에 비해 상대적으로 느립니다.</p>
  <p style="margin: 0.25rem 0;">- <span style="font-weight: bold;">추상화</span>, <span style="font-weight: bold;">캡슐화</span>, <span style="font-weight: bold;">상속성</span>, <span style="font-weight: bold;">다형성</span> 이라는 특징이 있습니다.</p>
  <br /><br />
  <p style="margin: 0.25rem 0;">절차지향 프로그래밍</p>
  <p style="margin: 0.25rem 0;">- 로직이 수행되어야 할 연속적인 계산 과정으로 이루어져 있습니다.</p>
  <p style="margin: 0.25rem 0;">- 코드의 가독성이 좋으며 실행 속도가 빠릅니다.</p>
  <p style="margin: 0.25rem 0;">- 모듈화하기 어렵고 유지 보수성이 떨어진다는 단점이 있습니다.</p>
  <br /><br /><br />
  <span style="font-size: 16px; font-weight: bold;">👀 순수 함수</span>
  <p>- 출력이 입력에만 의존하는 것을 의미합니다.</p>
  <br />
  <span style="font-size: 16px; font-weight: bold;">👀 고차 함수</span>
  <p> - 함수가 함수를 값처럼 매개변수로 받아 로직을 생성할 수 있는 것을 말합니다.</p>
  <br />
  <span style="font-size: 16px; font-weight: bold;">👀 추상화</span>
  <p> - 복잡한 시스템으로부터 핵심적인 개념 또는 기능을 간추려내는 것을 의미합니다.</p>
  <br />
  <span style="font-size: 16px; font-weight: bold;">👀 캡슐화</span>
  <p> - 객체의 속성과 메서드를 하나로 묶고 일부를 외부에 감추어 은닉하는 것을 말합니다.</p>
  <br />
  <span style="font-size: 16px; font-weight: bold;">👀 상속성</span>
  <p> - 상위 클래스의 특성을 하위 클래스가 이어받아서 재사용하거나 추가, 확장하는 것을 말합니다.</p>
  <br />
  <span style="font-size: 16px; font-weight: bold;">👀 다형성</span>
  <p> - 하나의 메서드나 클래스가 다양한 방법으로 동작하는 것을 말합니다.</p>
</blockquote>]]></content><author><name>Junghoo</name></author><category term="CS" /><category term="CS" /><category term="프로그래밍 패러다임" /><summary type="html"><![CDATA[프로그래밍 패러다임(programming paradigm)의 종류]]></summary></entry><entry><title type="html">디자인 패턴</title><link href="/jekyll-theme-yat/cs/2023/03/21/post19.html" rel="alternate" type="text/html" title="디자인 패턴" /><published>2023-03-21T00:00:00+00:00</published><updated>2023-03-21T00:00:00+00:00</updated><id>/jekyll-theme-yat/cs/2023/03/21/post19</id><content type="html" xml:base="/jekyll-theme-yat/cs/2023/03/21/post19.html"><![CDATA[<h2 id="디자인-패턴이란">디자인 패턴이란?</h2>

<blockquote style="margin: 1rem 0px 5rem;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1rem 1rem 1rem 2rem;
    color: #ECECEC;">
  <p style="margin: 0;">프로그램을 설계할 때 발생했던 문제점들을 객체 간의 상호 관계 등을 이용하여 해결할 수 있도록 하나의 '규약' 형태로 만들어 놓은것을 의미합니다.</p>
</blockquote>

<h2 id="디자인-패턴의-종류">디자인 패턴의 종류</h2>

<blockquote style="margin: 3rem 0px 7rem;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1.5rem 1rem 1.5rem 2rem;
    color: #ECECEC;">
  <p style="margin: 0.25rem 0;">- 크게 생성(Creational), 구조(Structural), 행위(Behavioral) 3가지로 분류됩니다.</p>
  <p style="margin: 0.25rem 0;">- GoF(Gang of Four) 디자인 패턴이라고 불리며, 에리히 감마(Erich Gamma), 리차드 헬름(Richard Helm), 랄프 존슨(Ralph Johnson), 존 블리시디스(John Vissides) 4명의 유명한 개발자들에 의해 고안되었는데 이 4명을 the Gang of Four 또는 GoF라고 부릅니다.</p>
</blockquote>
<p><br /><br /></p>

<h3 id="싱글톤-패턴-singleton-pattern">싱글톤 패턴 (Singleton Pattern)</h3>

<div style="text-align: center; width: 534px;">
  <img style="margin: 3rem auto 2.5rem;" width="534" src="https://user-images.githubusercontent.com/76745621/226673612-f2968c72-b8d5-43d2-913a-95fc161e7fe5.png" alt="싱글톤 패턴 예시 이미지" />
  <br />
  <span style="font-weight: bold">이미지 출저 -</span>
  <a style="color: dodgerblue" href="https://refactoring.guru/ko" target="_blank" rel="noopener noreferrer">Refactoring.Guru</a>
</div>
<blockquote style="margin: 3rem 0px 7rem;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1.5rem 1rem 1rem 2rem;
    color: #ECECEC;">
  <p style="margin: 0.25rem 0;">- 특정 클래스에 객체 인스턴스가 하나만 만들어지도록 해주는 패턴입니다.</p>
  <p style="margin: 0.25rem 0;">- 전역 변수를 사용할 때와 마찬가지로 객체 인스턴스를 어디서든지 액세스 할 수 있게 만들 수 있습니다.</p>
  <p style="margin: 0.25rem 0;">- 클래스 인스턴스를 하나만 만들고 그 인스턴스로의 전역 접근을 제공합니다.</p>
  <br />
  <span style="font-size: 16px; font-weight: bold;">👍 장점</span>
  <p>- 하나의 인스턴스를 만들어 놓고 다른 모듈들이 공유하며 사용하기 때문에, 인스턴스를 생성할 때 드는 비용이 줄어듭니다.</p>
  <br />
  <span style="font-size: 16px; font-weight: bold;">🥲 단점</span>
  <p> - 의존성이 높아지고 모듈간의 결합을 강하게 만들수 있습니다.</p>
  <p>- 독립적인 인스턴스를 만들기가 어렵기 때문에 TDD(Test Driven Development)를 하는데 있어서 걸림돌이 될 수 있습니다.</p>
</blockquote>

<h3 id="팩토리-패턴-factory-pattern">팩토리 패턴 (Factory Pattern)</h3>

<blockquote style="margin: 3rem 0px 7rem;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1.5rem 1rem 1rem 2rem;
    color: #ECECEC;">
  <p style="margin: 0.25rem 0;">- 부모 클래스에서 객체들을 생성할 수 있는 인터페이스를 제공하지만, 자식 클래스들이 생성될 객체들의 유형을 변경할 수 있도록 하는 생성 패턴입니다. </p>
  <br />
  <span style="font-size: 16px; font-weight: bold;">👍 장점</span>
  <p>- 상위 클래스와 하위 클래스가 분리되기 때문에 느슨한 결합을 가지며 더 많은 유연성을 갖게 됩니다.</p>
  <p>- 객체 생성 로직이 따로 떼어져 있어서 코드의 유지 보수성이 증가됩니다.</p>
  <br />
  <span style="font-size: 16px; font-weight: bold;">🥲 단점</span>
  <p> - 패턴을 구현하기 위해 많은 새로운 자식 클래스들을 도입해야 하므로 코드가 더 복잡해질 수 있습니다.</p>
</blockquote>

<h3 id="전략-패턴-strategy-pattern">전략 패턴 (Strategy Pattern)</h3>

<blockquote style="margin: 3rem 0px 7rem;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1.5rem 1rem 1rem 2rem;
    color: #ECECEC;">
  <p style="margin: 0.25rem 0;">- 정책 패턴(policy pattern)이라고도 하며, 객체의 행위를 바꾸고 싶은 경우 전략이라고 부르는 캡슐화한 알고리즘을 '컨텍스트' 안에서 바꿔주면서 상호 교체가 가능하게 만드는 패턴입니다.</p>
  <br />
  <span style="font-size: 16px; font-weight: bold;">👀 컨텍스트</span>
  <p>- 상황, 맥락, 문맥을 의미하며 개발자가 어떠한 작업을 완료하는 데 필요한 모든 관련 정보.</p>
  <br />
</blockquote>

<h3 id="옵저버-패턴-observer-pattern">옵저버 패턴 (Observer Pattern)</h3>

<blockquote style="margin: 3rem 0px 7rem;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1.5rem 1rem 1rem 2rem;
    color: #ECECEC;">
  <p style="margin: 0.25rem 0;">- 주체가 어떤 객체(subject)의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 디자인 패턴입니다.</p>
  <br />
  <p>- 자바스크립트에서는 프록시 객체를 통해서 구현할 수 있습니다.</p>
  <br />
</blockquote>

<h3 id="프록시-패턴-proxy-pattern">프록시 패턴 (Proxy Pattern)</h3>

<blockquote style="margin: 3rem 0px 7rem;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1.5rem 1rem 1rem 2rem;
    color: #ECECEC;">
  <p style="margin: 0.25rem 0;">- 대상 객체(subject)에 접근하기 전 그 접근에 대한 흐름을 가로채 대상 객체 앞단의 인터페이스 역할을 하는 디자인 패턴입니다.</p>
  <br />
   <p>- 객체의 속성, 변환 등을 보완하며 보안, 데이터 검증, 캐싱, 로깅에 사용되며, '프록시 서버'로도 활용됩니다.</p>
  <br />
  <span style="font-size: 16px; font-weight: bold;">👀 프록시 서버(proxy server)</span>
  <p>- 서버와 클라이언트 사이에서 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템이나 응용 프로그램.</p>
</blockquote>

<h3 id="이터레이터-패턴-iterator-pattern">이터레이터 패턴 (Iterator Pattern)</h3>

<blockquote style="margin: 3rem 0px 7rem;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1.5rem 1rem 1rem 2rem;
    color: #ECECEC;">
  <p style="margin: 0.25rem 0;">- 이터레이터(iterator)를 사용하여 컬렉션의 요소들에 접근하는 디자인 패턴입니다.</p>
  <br />
  <p>- 순회할 수 있는 여러 가지 자료형의 구조와는 상관없이 이터레이터라는 하나의 인터페이스로 순회가 가능합니다.</p>
</blockquote>

<h3 id="노출모듈-패턴-revealing-module-pattern">노출모듈 패턴 (Revealing Module Pattern)</h3>

<blockquote style="margin: 3rem 0px 7rem;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1.5rem 1rem 1rem 2rem;
    color: #ECECEC;">
  <p style="margin: 0.25rem 0;">- 즉시 실행 함수를 통해 private, public 같은 접근 제어자를 만드는 패턴입니다.</p>
  <br />
  <p>- 자바스크립트는 전역 범위에서 스크립트가 실행되기 때문에 노출모듈 패턴을 통해 private, public 접근 제어자를 구현하기도 합니다.</p>
</blockquote>

<h3 id="mvc-패턴">MVC 패턴</h3>

<div style="text-align: center; width: 534px;">
  <img style="margin: 1.5rem auto 1rem;" width="534" src="https://user-images.githubusercontent.com/76745621/226717176-940547c1-1cdf-4a58-8612-57fc4d7455e5.png" alt="싱글톤 패턴 예시 이미지" />
  <span style="font-weight: bold">이미지 출저 -</span>
    <a style="color: dodgerblue" href="https://developer.mozilla.org/ko/docs/Glossary/MVC" target="_blank" rel="noopener noreferrer"> MDN Web Docs (MVC)</a>
</div>
<blockquote style="margin: 1.5rem 0px 7rem;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1.5rem 1rem 1rem 2rem;
    color: #ECECEC;">
  <p style="margin: 0.25rem 0;">- 모델(Model), 뷰(View), 컨트롤러(Controller)로 이루어진 디자인 패턴입니다.</p>
  <br />
  <span style="font-size: 16px; font-weight: bold;">👍 장점</span>
  <p>- 재사용성과 확장성이 용이합니다.</p>
  <p>- 개발 프로세스에서 각각의 구성 요소에만 집중해서 개발할 수 있습니다.</p>
  <br />
  <span style="font-size: 16px; font-weight: bold;">🥲 단점</span>
  <p> - 애플리케이션이 복잡해질수록 모델과 뷰의 관계가 복잡해집니다.</p>
</blockquote>

<h3 id="mvp-패턴">MVP 패턴</h3>

<div style="text-align: center; width: 534px;">
  <img style="margin: 1.5rem auto 1rem;" width="534" src="https://user-images.githubusercontent.com/76745621/226719793-328fb559-1174-4533-8a8a-d59f6578609f.png" alt="싱글톤 패턴 예시 이미지" />
</div>

<blockquote style="margin: 3rem 0px 7rem;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1.5rem 1rem 1.5rem 2rem;
    color: #ECECEC;">
  <p style="margin: 0.25rem 0;">- MVC 패턴으로부터 파생되었으며 MVC에서 C에 해당하는 컨트롤러가 프레젠터(presenter)로 교체돈 패턴입니다.</p>
  <br />
  <p style="margin: 0.25rem 0;">- 뷰와 프레젠터는 일대일 관계이기 떄문에 MVC 패턴보다 더 강한 결합을 지닌 디자인 패턴이라고 볼 수 있습니다.</p>
</blockquote>

<h3 id="mvvm-패턴">MVVM 패턴</h3>

<div style="text-align: center; width: 534px;">
  <img style="margin: 1.5rem auto 1rem;" width="534" src="https://user-images.githubusercontent.com/76745621/226722400-7341657f-bbd4-41a9-a3a5-ad7881220e8b.jpeg" alt="싱글톤 패턴 예시 이미지" />
</div>

<blockquote style="margin: 3rem 0px 7rem;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1.5rem 1rem 1.5rem 2rem;
    color: #ECECEC;">
  <p style="margin: 0.25rem 0;">- MVC의 C에 해당하는 컨트롤러가 뷰모델(View Model)로 바뀐 패턴입니다.</p>
  <br />
  <p style="margin: 0.25rem 0;">- 뷰모델은 뷰를 더 추상화한 계층이며, MVC 패턴과는 다르게 커맨드와 데이터 바인딩을 가지는 것이 특징입니다.</p>
  <br />
  <span style="font-size: 16px; font-weight: bold;">👍 장점</span>
  <p>- 뷰와 뷰모델 사이의 양방향 데이터 바인딩을 지원하기 때문에 UI를 별도의 코드 수정 없이 재사용할 수 있습니다.</p>
  <p>- 단위 테스팅하기 쉽습니다.</p>
  <br />
  <span style="font-size: 16px; font-weight: bold;">🥲 단점</span>
  <p> - 간단한 UI에서 오히려 ViewModel을 설계하는 어려움이 있을 수 있습니다.</p>
  <p> - 데이터 바인딩이 필수적으로 요구됩니다.</p>
</blockquote>]]></content><author><name>Junghoo</name></author><category term="CS" /><category term="CS" /><category term="디자인 패턴" /><summary type="html"><![CDATA[디자인 패턴의 종류와 활용]]></summary></entry><entry><title type="html">변수 선언의 실행 시점과 변수 호이스팅</title><link href="/jekyll-theme-yat/javascript/2023/01/05/post18.html" rel="alternate" type="text/html" title="변수 선언의 실행 시점과 변수 호이스팅" /><published>2023-01-05T00:00:00+00:00</published><updated>2023-01-05T00:00:00+00:00</updated><id>/jekyll-theme-yat/javascript/2023/01/05/post18</id><content type="html" xml:base="/jekyll-theme-yat/javascript/2023/01/05/post18.html"><![CDATA[<p>자바스크립트에서는 변수 선언문보다 미리 변수를 참조하는 코드가 있다면 변수가 선언되지 않았다는 ReferenceError 가 아닌 undefined 라는 값을 보여주게 됩니다. 자바스크립트는 코드를 작성한 순서대로 차례차례 읽게 되는 인터프리터 언어라고 알고 있는데 왜 이런 현상이 발생하게 되는걸까요?</p>
<p>자바스크립트가 런타임 이전에 코드 평가 과정을 거치면서 소스코드를 실행하기 위한 준비를 하는데 이때 모든 선언문을 자바스크립트 엔진이 미리 코드가 실행되기 전에 찾아내서 실행을 하기 때문인데요. 오늘은 자바스크립트의 변수 호이스팅에 대해서 작성해보고자 합니다.</p>
<p><br /></p>

<h2 id="호이스팅hoisting">호이스팅(hoisting)</h2>

<blockquote style="margin: 1rem 0px 5rem;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1rem 1rem 1rem 2rem;
    color: #ECECEC;">
  <p style="margin: 0;">선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트의 고유한 특징입니다.</p>
</blockquote>

<h3 id="발생-원인">발생 원인</h3>

<blockquote style="margin: 1rem 0px 5rem;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1rem 1rem 1rem 2rem;
    color: #ECECEC;">
  <p style="margin: 0;">소스코드가 한 줄씩 순차적으로 실행되는 시점, 런타임(runtime)이 아니라 그 이전 단계에서 자바스크립트가 소스코드안의 모든 선언문을 찾아내서 먼저 실행하기 때문입니다.</p>
</blockquote>

<h3 id="동작-과정">동작 과정</h3>

<blockquote style="margin: 1rem 0px 5rem;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1rem 1rem 1rem 2rem;
    color: #ECECEC;">
  <ol style="padding-left: .7rem">
    <li>런타임(runtime) 이전에 소스코드의 평가 과정을 거치면서 소스코드 실행 준비.</li>
    <li>평가 과정에서 자바스크립트 엔진이 모든 선언문을 찾고 먼저 실행.</li>
    <li>소스코드의 평가 과정이 끝나면 모든 선언문을 제외하고 소스코드를 순차적으로 실행.</li>
  </ol>
</blockquote>

<h3 id="예시">예시</h3>

<p><img style="margin: 1rem auto" width="405" alt="스크린샷 2023-01-05 오후 1 11 04" src="https://user-images.githubusercontent.com/76745621/210702031-a65d0fcc-8326-4bd2-81a0-7880780dfe25.png" /></p>

<blockquote style="margin: 1rem 0px 5rem;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1rem 1rem 1rem 2rem;
    color: #ECECEC;">
    <ul style="padding-left: .7rem;">
      <li>자바스크립트 엔진은 변수 선언과 값의 할당을 하나의 문으로 단축 표현한 코드를 선언문과 할당문으로 나누어 실행. (이때 선언문은 런타임 이전, 할당문은 런타임에 실행)</li>
      <li>런타임 이전에 실행되는 값이 아직 할당되어지지 않은 변수 선언문(str)에 자바스크립트가 undefined로 값을 초기화.</li>
      <li>이후 런타임에 실행되는 할당문을 통해 기존에 선언되었던 변수의 값은 undefined에서 새롭게 할당 된 문자형 타입 'banana'로 변경.</li>
    </ul>
</blockquote>]]></content><author><name>Junghoo</name></author><category term="JavaScript" /><category term="모던 자바스크립트" /><summary type="html"><![CDATA[자바스크립트 내부 앤진에서의 호이스팅의 동작 방식]]></summary></entry><entry><title type="html">자바스크립트란?</title><link href="/jekyll-theme-yat/javascript/2023/01/02/post17.html" rel="alternate" type="text/html" title="자바스크립트란?" /><published>2023-01-02T00:00:00+00:00</published><updated>2023-01-02T00:00:00+00:00</updated><id>/jekyll-theme-yat/javascript/2023/01/02/post17</id><content type="html" xml:base="/jekyll-theme-yat/javascript/2023/01/02/post17.html"><![CDATA[<blockquote style="margin: 2rem 0px 5rem;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1rem 1rem 1rem 2rem;
    color: #ECECEC;">
  <p>모던 자바스크립트를 참조하여 작성하였습니다.</p>
</blockquote>

<h2 id="자바스크립트란">자바스크립트란</h2>

<p>1995년, 넷스케이프 커뮤니케이션즈는 웹페이지의 보조적인 기능을 수행하기 위해 브라우저에서 동작하는 경량 프로그래밍 언어를 도입하게 되고 이렇게 탄생한 것이 바로 브렌던 아이크가 개발한 자바스크립트입니다.</p>
<p style="margin-bottom: 3rem">1996년 3월, 넷스케이프 커뮤니케이션즈의 웹 브라우저인 넷스케이프 내비게이터2 에 탑재되었고 'Mocha'(모카)로 명명되었고 그해 9월 LiveScript(라이브스크립트)로 이름이 변경되었다가 12월에 'JavaScript'라는 이름으로 최종 명명되었습니다.</p>

<h3 id="표준화">표준화</h3>

<p>마이크로소프트에서 개발된 JavaScript의 파생 버전인 JScript가 등장하게되고 JScript와 JavaScript는 시장 점유율을 높이기 위해서 자사 브라우저에서만 동작하는 기능을 경쟁적으로 추가하기 시작했습니다. 이로 인해 <b>크로스 브라우징 이슈</b>가 발생하게 되면서 표준화된 JavaScript의 필요성이 대두되었고 1996년 11월 넷스케이프 커뮤니케이션즈는 <b>ECMA 인터내셔널</b>에 JavaScript의 표준화를 요청합니다.</p>
<p><br /><br /></p>

<h4 id="-크로스-브라우징-이슈란">👀 크로스 브라우징 이슈란?</h4>

<p>HTML, CSS, JS 파일을 기준으로 모든 브라우저에서 동일하게 랜더링 되지 않는 현상.</p>
<p><br /></p>

<h4 id="-ecma-인터내셔널">👀 ECMA 인터내셔널</h4>

<p>컴퓨터 시스템의 표준을 관리하는 비영리 표준화 기구.</p>
<p><br /><br /></p>

<h4 id="ecmascript-버전별-특징">ECMAScript 버전별 특징</h4>

<table style="border: 1px solid; margin: 1rem 0 5rem">
  <thead>
      <tr>
          <th>버전</th>
          <th>출시 연도</th>
          <th>특징</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>ES1</td>
          <td>1997</td>
          <td>초판</td>
      </tr>
      <tr>
          <td>ES2</td>
          <td>1998</td>
          <td>ISO/IEC 16262 국제 표준과 동일한 규격을 적용</td>
      </tr>
      <tr>
          <td>ES3</td>
          <td>1999</td>
          <td>정규 표현식, try...catch</td>
      </tr>
      <tr>
          <td rowspan="3">ES5</td>
          <td rowspan="3">2009</td>
          <td>HTML5와 함께 출현한 표준안.</td>
      </tr>
      <tr>
          <td>JSON, strict mode, 접근자 프로퍼티, 프로퍼티 어트리뷰트 제어, 향상된 배열</td>
      </tr>
      <tr>
        <td>조작 기능(forEach, map, filter, reduce, some, every</td>
      </tr>
      <tr>
          <td rowspan="3">ES6(ECMAScript 2015)</td>
          <td rowspan="3">2015</td>
          <td>let/const, 클래스, 화살표 함수, 템플릿 리터럴, 디스트럭처링 할당, 스프레드</td>
      </tr>
      <tr>
          <td>문법, rest 파라미터, 심벌, 프로미스, Map/Set, 이터러블, for...of,</td>
      </tr>
      <tr>
        <td>제너레이터, Proxy, 모듈 import / export</td>
      </tr>
      <tr>
          <td rowspan="2">ES7(ECMAScript 2016)</td>
          <td rowspan="2">2016</td>
          <td>지수(**) 연산자, Array.prototype.includes,</td>
      </tr>
      <tr>
          <td>String.prototype.includes</td>
      </tr>
      <tr>
          <td rowspan="2">ES8(ECMAScript 2017)</td>
          <td rowspan="2">2017</td>
          <td>async/await, Object 정적 메서드(Object.values, Object.entries,</td>
      </tr>
      <tr>
        <td>Object.getOwnPropertyDescriptors)</td>
      </tr>
      <tr>
          <td rowspan="2">ES9(ECMAScript 2018)</td>
          <td rowspan="2">2018</td>
          <td>Object rest/spread 프로퍼티, Promise.prototype.finally,</td>
      </tr>
      <tr>
          <td>String.prototype.includes</td>
      </tr>
      <tr>
          <td rowspan="2">ES10(ECMAScript 2019)</td>
          <td rowspan="2">2019</td>
          <td>Object.fromEntries, Array.prototype.flat,</td>
      </tr>
      <tr>
          <td>Array.prototype.flatMap, optional catch binding</td>
      </tr>
      <tr>
          <td rowspan="3">ES11(ECMAScript 2020)</td>
          <td rowspan="3">2020</td>
          <td>String.prototype.matchAll, BigInt, globalThis,</td>
      </tr>
      <tr>
          <td>Promise.allSettled, null 병합 연산자, 옵셔널 체이닝 연산자,</td>
      </tr>
      <tr>
          <td>for...in enumeration order</td>
      </tr>
  </tbody>
</table>

<h3 id="자바스크립트-성장의-역사">자바스크립트 성장의 역사</h3>

<p>초창기 JavaScript는 단순히 HTML과 CSS파일을 렌더링 해주는 역할만 가지고 있었지만 <b>Ajax</b>, <b>V8 자바스크립트 엔진</b>이 등장하면서 기하급수적으로 성장하게 되었고 데스크톱 애플리케이션과 비교해도 손색없는 성능과 사용자 경험을 제공하는 것이 필수가 되었습니다. 개발 규모와 복잡도가 상승하게 되면서 이전의 개발 방식으로는 개발을 수행하기 어려워졌고 이러한 요구에 발맞춰 나온것이 바로 <b>SPA(Single page aplication)</b> 입니다. SPA가 등장하게 되면서 React, Vue, Svelte 등의 다양한 SPA 프레임워크/라이브러리가 생겨났고 현재가지도 많은 사용층을 보유하고 있습니다.</p>
<p><br /></p>

<h4 id="-ajax란">👀 Ajax란</h4>

<blockquote style="margin: 1rem 0px 5rem;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1rem 1rem 1rem 2rem;
    color: #ECECEC;">
    <p style="margin: 0">서버와 브라우저가 XMLHttpRequest를 통해  비동기 방식으로 데이터를 교환할 수 있는 통신 기능</p>
</blockquote>

<h4 id="-v8-자바스크립트-엔진">👀 V8 자바스크립트 엔진</h4>

<blockquote style="margin: 1rem 0px 5rem;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1rem 1rem 1rem 2rem;
    color: #ECECEC;">
    <p style="margin: 0">웹 애플리케이션을 구축하려는 시도가 늘면서 더욱 빠르게 동작하는 자바스크립트 엔진의 필요성이 대두되었고 2008년 구글에서 개발한 자바스크립트 엔진입니다. V8 엔진 등장 이후 과거 웹 서버에서 수행되던 로직들이 클라이언트(브라우저)로 이동했고, 웹 애플리케이션 개발 영역에서 프론트엔드 개발 영역이 주목받기 시작하는 계기가 되었습니다. 이후 V8 엔진을 기반으로 만들어진 <b>Node.js</b>의 등장으로 자바스크립트는 브라우저를 벗어나 서버 사이드 애플리케이션(SSR) 개발에서도 사용할 수 있는 범용 프로그래밍 언어가 되었습니다.</p>
</blockquote>

<h4 id="-nodejs란">👀 Node.js란</h4>

<blockquote style="margin: 1rem 0px 1rem;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1rem 1rem 1rem 2rem;
    color: #ECECEC;">
    <p style="margin: 0">2009년 Ryan Dhal이 발표한 구글 V8 자바스크립트 엔진으로 브라우저 이외의 환경에서도 자바스크립트를 동작할 수 있도록 빌드된 자바스크립트 런타임 환경입니다. 주로 서버 사이드 애플리케이션 개발에 사용됩니다.</p>
</blockquote>
<p><a style="color: dodgerblue" href="https://nodejs.org/en/" target="_blank" rel="noopener noreferrer">nodeJS 공식 홈페이지</a></p>

<p><br /><br /></p>

<h3 id="es6-브라우저-지원-현황">ES6 브라우저 지원 현황</h3>

<p><img style="margin: 2rem auto 1rem" width="1264" alt="스크린샷 2023-01-03 오후 5 53 11" src="https://user-images.githubusercontent.com/76745621/210325539-d24ab7f7-c9f3-4091-b077-8e13793b423c.png" /></p>
<p>참조 : <a style="color: dodgerblue" href="https://caniuse.com/es6" target="_blank" rel="noopener noreferrer">Can I use</a></p>
<blockquote style="margin: 1rem 0px .5rem;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1rem 1rem 1rem 2rem;
    color: #ECECEC;">
    <p style="margin: 0">인터넷 익스플로러를 제외한 모던 브라우저의 대부분은 ES6를 지원하고 있습니다. </p>
    <p>만약 지원하지 않는 구형 브라우저를 고려해야 하는 상황이라면 Babel과 같은 컴파일러를 사용해야할 필요가 있습니다.</p>
</blockquote>]]></content><author><name>Junghoo</name></author><category term="JavaScript" /><category term="모던 자바스크립트" /><summary type="html"><![CDATA[모던 자바스크립트를 참조하여 작성하였습니다.]]></summary></entry><entry><title type="html">Redux로 간단한 Todo 만들기</title><link href="/jekyll-theme-yat/react/2022/12/18/post16.html" rel="alternate" type="text/html" title="Redux로 간단한 Todo 만들기" /><published>2022-12-18T00:00:00+00:00</published><updated>2022-12-18T00:00:00+00:00</updated><id>/jekyll-theme-yat/react/2022/12/18/post16</id><content type="html" xml:base="/jekyll-theme-yat/react/2022/12/18/post16.html"><![CDATA[<p>리엑트는 하위 컴포넌트로 데이터를 전달할 때 state 값을 props로 전달하게 됩니다.</p>
<p>하지만 컴포넌트의 깊이가 깊어지고 프로젝트가 점점 더 커질 경우에는 데이터의 흐름을 파악하고 관리하는게 어렵게 됩니다.</p>
<p><br /><br /></p>

<p><img src="https://user-images.githubusercontent.com/76745621/208308516-bfe21f4a-dabb-49d3-8203-e8ab4564a372.png" alt="image" /></p>

<p><br /></p>
<p>위 이미지를 보면 D컴포넌트는 props를 통해 B, C 컴포넌트를 거쳐 데이터를 전달 받는 걸 알 수 있습니다.</p>
<p>하지만 만약 프로젝트의 규모가 커져서 컴포넌트의 개수가 100개라고 가정을 한다면...</p>
<p>예를 들어 50번 컴포넌트에 데이터를 전달하기 위해서 하위 컴포넌트로 props를 계속해서 전달 해야 하는데요.</p>
<p>이러한 현상을 Props Drilling 이라고 하는데요.</p>
<p>데이터가 중간에 예기치 않게 전달이 되지 않고 오류가 발생하게 된다면 원인을 찾는 시간이 엄청 오래 걸리고 이러한 프로젝트를 유지보수하는 것도 결코 쉽지 않을것입니다.</p>
<p><br /><br /></p>
<p>이런 Props Drilling 문제를 해결하기 위한 방법으로는 상태 관리 라이브러리를 사용하는 방법이 있습니다.</p>
<p>대표적인 상태 관리 라이브러리는 
<a style="color: dodgerblue" href="https://ko.redux.js.org/" target="_blank" rel="noopener noreferrer">Redux</a>, 
<a style="color: dodgerblue" href="https://recoiljs.org/ko/" target="_blank" rel="noopener noreferrer">Recoil</a>, 
<a style="color: dodgerblue" href="https://ko.mobx.js.org/README.html" target="_blank" rel="noopener noreferrer">MobX</a>,
<a style="color: dodgerblue" href="https://ko.reactjs.org/docs/context.html" target="_blank" rel="noopener noreferrer">Context API</a>
 가 있습니다.</p>
<p>이번 글에서는 Redux를 사용해서 간단한 Todo 예제를 만들어 보고 학습한 것을 작성하려고 합니다.</p>
<p><br /><br /></p>

<h2 id="redux-설치">Redux 설치</h2>

<blockquote style="margin: 2rem 0px;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1rem 1rem 1rem 2rem;
    color: #ECECEC;">
  <p>Redux는 리엑트에서 자체적으로 제공하지 않기 때문에 별도로 redux 라이브러리를 설치해야 합니다.</p>
  <p>- npm을 통한 설치 : npm install redux react-redux</p>
  <p>- yarn을 통한 설치 : yarn add redux react-redux</p>
</blockquote>
<p><br /><br /></p>

<h2 id="redux-동작-방식">Redux 동작 방식</h2>

<p><img style="margin: 1rem auto;" width="534" alt="스크린샷 2022-12-19 오전 2 11 39" src="https://ko.redux.js.org/assets/images/ReduxDataFlowDiagram-49fa8c3968371d9ef6f2a1486bd40a26.gif" /></p>
<blockquote style="margin: 2rem 0px;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1rem 1rem 1rem 2rem;
    color: #ECECEC;">
  <p>순서 : UI -&gt; Dispatch -&gt; Action -&gt; Reducer -&gt; UI</p>
</blockquote>
<p><br /><br /><br /></p>

<h2 id="redux-사용해서-todo-만들기">Redux 사용해서 Todo 만들기</h2>

<p><img style="margin: 1rem auto 5rem 0;" width="534" alt="스크린샷 2022-12-19 오전 2 11 39" src="https://user-images.githubusercontent.com/76745621/208310649-1735f766-ca69-4899-94d6-7d7cf4f8b53a.png" /></p>

<h3 id="reducerjs">reducer.js</h3>

<p><img style="margin: 1rem auto;" width="476" alt="스크린샷 2022-12-19 오전 2 42 31" src="https://user-images.githubusercontent.com/76745621/208311700-c8090321-86d4-4f3d-9a27-f7016c76152c.png" /></p>

<blockquote style="margin: 2rem 0px;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1rem 1rem 1rem 2rem;
    color: #ECECEC;">
  <p>- 전달 받은 action 객체에 따라서 기존 state를 참조하여 수정 후 반환 합니다.</p>
  <p>- 바로 이 reducer에 있는 state가 앞으로 모든 컴포넌트에서 전역적으로 사용되게 됩니다. </p>
</blockquote>
<p><br /><br /><br /></p>

<h3 id="indexjs">index.js</h3>

<p><img style="margin: 2rem auto 0px;" width="482" alt="스크린샷 2022-12-19 오전 2 22 08" src="https://user-images.githubusercontent.com/76745621/208311118-baf85d29-690e-4ce8-acf0-991eab84a4c0.png" /></p>

<blockquote style="margin: 2rem 0px;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1rem 1rem 1rem 2rem;
    color: #ECECEC;">
  <p>가장 최상단 컴포넌트를 Provider로 감싸주고 props로 store를 넘겨주게 되면 하위에 있는 컴포넌트들은 Props Drilling을 거치지 않고 state를 직접적으로 사용 할 수 있게 됩니다.</p>
</blockquote>
<p><br /><br /></p>

<h3 id="actionjs">action.js</h3>

<p><img style="margin: 2rem auto 0px;" width="280" alt="스크린샷 2022-12-19 오전 2 58 56" src="https://user-images.githubusercontent.com/76745621/208312870-916b703c-b1e1-465d-a58f-52512597ab41.png" /></p>

<blockquote style="margin: 2rem 0px;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1rem 1rem 1rem 2rem;
    color: #ECECEC;">
  <p>Dispatch를 통해 reducer에 전달해줄 action 함수들 입니다.</p>
</blockquote>
<p><br /><br /><br /></p>

<h3 id="addtodojs">AddTodo.js</h3>

<p><img style="margin: 2rem auto 0px;" width="492" alt="스크린샷 2022-12-19 오전 3 24 08" src="https://user-images.githubusercontent.com/76745621/208313172-09e6be9b-8ba9-4bbd-83e8-de4cbb159241.png" /></p>

<blockquote style="margin: 2rem 0px;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1rem 1rem 1rem 2rem;
    color: #ECECEC;">
  <p>1. useDispatch() 를 통해서 input 값을 action 함수에 전달하게 됩니다.</p>
  <p>2. 작성된 action 객체는 reducer로 전달되고 state를 갱신시키게 됩니다.</p>
  <p></p>
</blockquote>
<p><br /><br /><br /></p>

<h3 id="todolistjs">TodoList.js</h3>

<p><img style="margin: 2rem auto 0px;" width="546" alt="스크린샷 2022-12-19 오전 3 34 17" src="https://user-images.githubusercontent.com/76745621/208313583-73ccfc39-e984-4e1a-895f-867f58f48ba8.png" /></p>

<blockquote style="margin: 2rem 0px;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1rem 1rem 1rem 2rem;
    color: #ECECEC;">
  <p>useSelector()를 통해서 store에 있는 state를 접근하고 사용할 수 있게 됩니다.</p>
</blockquote>
<p><br /><br /></p>

<h2 id="후기">후기</h2>

<blockquote style="margin: 2rem 0px;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1rem 1rem 1rem 2rem;
    color: #ECECEC;">
  <p>Redux를 사용하면 상태 관리에 용이성과 데이터 흐름을 쉽게 파악할 수 있지만 그만큼 추가해야 하는 코드들도 상당히 많아지게 되는 아이러니한 상황이 발생하는 것 같습니다. 프로젝트 규모에 맞춰서 적절한 상태 관리 라이브러리를 사용하는 연습이 많이 필요하다는 생각이 듭니다...</p>
</blockquote>
<p><br /><br /></p>]]></content><author><name>Junghoo</name></author><category term="React" /><category term="Redux" /><category term="제로베이스 프론트엔드 스쿨" /><summary type="html"><![CDATA[Redux로 전역 상태 관리하여 Todo 만들기]]></summary></entry><entry><title type="html">CSS-in-JS (styled-components)</title><link href="/jekyll-theme-yat/react/2022/12/11/post15.html" rel="alternate" type="text/html" title="CSS-in-JS (styled-components)" /><published>2022-12-11T00:00:00+00:00</published><updated>2022-12-11T00:00:00+00:00</updated><id>/jekyll-theme-yat/react/2022/12/11/post15</id><content type="html" xml:base="/jekyll-theme-yat/react/2022/12/11/post15.html"><![CDATA[<p>React에서 스타일링을 하는 방법은 정말 다양합니다.</p>
<p>하지만 이번 글에서는 styled-components로 스타일을 적용하는 방법을 말씀드리고자 합니다.</p>
<p><br /><br /></p>

<h2 id="styled-components란">styled-components란?</h2>

<blockquote style="margin: 2rem 0px;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1rem 1rem 1rem 2rem;
    color: #ECECEC;">
  <p>- Javascript 파일 안에서 CSS를 처리 할 수 있게 해주는 대표적인 라이브러리입니다.</p>
  <p>- React에서 기본적으로 제공하지 않기 때문에 따로 라이브러리를 설치 해주어야 합니다.</p>
  <p>- 또한, SCSS 라이브러리 설치 없이 SCSS 문법을 사용할 수 있습니다.</p>
</blockquote>

<p><span style="font-weight: bold">참고 -</span>
<a style="color: dodgerblue" href="https://styled-components.com/docs/basics#motivation" target="_blank" rel="noopener noreferrer">styled-components(Basics-Motivation)</a>
<br /><br /><br /><br /><br /></p>

<h2 id="설치방법">설치방법</h2>

<blockquote style="margin: 2rem 0px;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1rem 1rem 1rem 2rem;
    color: #ECECEC;">
  <p>- npm을 통한 설치 : npm install styled-components</p>
  <p>- yarn을 통한 설치 : yarn add styled-components</p>
</blockquote>
<p><br /><br /></p>

<h2 id="사용방법">사용방법</h2>

<blockquote style="margin: 2rem 0px;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1rem 1rem 1rem 2rem;
    color: #ECECEC;">
  <p>1. 설치한 styled-components로 부터 styled 객체를 import 합니다.</p>
  <p>2. styled.태그명을 작성 후 백틱(``)기호 안에 적용하고자 하는 스타일을 작성 후 사용하고자 하는 변수(컴포넌트명)에 저장 합니다.</p>
  <p>3. return안의 랜더링 되는 코드에 적용을 해주면 작성한 스타일드 컴포넌트가 정상적으로 랜더링되는 것을 확인 할 수 있습니다.</p>
</blockquote>
<p><br /><br /></p>

<h3 id="예시1">예시1</h3>

<p><img style="margin: 1rem auto 5rem 0;" width="328" alt="스크린샷 2022-12-12 오전 2 12 22" src="https://user-images.githubusercontent.com/76745621/206918265-3d125d1d-9c4b-4e73-9673-b2a8ec3f6835.png" /></p>

<h3 id="결과1">결과1</h3>

<p><img style="margin: 1rem auto 1rem 0;" width="430" alt="스크린샷 2022-12-12 오전 2 26 47" src="https://user-images.githubusercontent.com/76745621/206918920-3b599b2f-a0b0-4c60-b962-bd308dc91725.png" />
<br /><br /></p>

<blockquote style="margin: 2rem 0px;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1rem 1rem 1rem 2rem;
    color: #ECECEC;">
  <p>또한 styled-components는 기존 리엑트 컴포넌트처럼 받아온 props를 활용하여 스타일링을 작성할 수 있습니다.</p>
</blockquote>
<p><br /><br /></p>

<h3 id="예시2">예시2</h3>

<p><img style="margin: 1rem auto 5rem 0;" width="417" alt="스크린샷 2022-12-12 오전 3 01 06" src="https://user-images.githubusercontent.com/76745621/206920498-98b5109a-6760-4c86-a79d-66baad3a2e85.png" /></p>

<h3 id="결과2">결과2</h3>

<p><img style="margin: 1rem auto 5rem 0;" width="430" alt="스크린샷 2022-12-12 오전 3 03 38" src="https://user-images.githubusercontent.com/76745621/206920620-de651813-43b4-4022-aed4-9356087af1c7.png" />
<br /><br /></p>

<h2 id="후기">후기</h2>

<blockquote style="margin: 2rem 0px;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1rem 1rem 1rem 2rem;
    color: #ECECEC;">
  <p>따로 스타일 파일을 별도로 만들지 않고 컴포넌트를 작성하면서, 해당 컴포넌트의 스타일을 적용할 수 있다는 점에서 만족도가 높았고 많은 개발자분들이 왜 이 styled-components 라이브러리를 사용을 하는지에 대해서 한번 더 생각해볼 수 있었습니다.</p>
</blockquote>]]></content><author><name>Junghoo</name></author><category term="React" /><category term="styled-component" /><category term="제로베이스 프론트엔드 스쿨" /><summary type="html"><![CDATA[styled-components 설치와 사용 방법]]></summary></entry><entry><title type="html">JSX</title><link href="/jekyll-theme-yat/react/2022/12/04/post14.html" rel="alternate" type="text/html" title="JSX" /><published>2022-12-04T00:00:00+00:00</published><updated>2022-12-04T00:00:00+00:00</updated><id>/jekyll-theme-yat/react/2022/12/04/post14</id><content type="html" xml:base="/jekyll-theme-yat/react/2022/12/04/post14.html"><![CDATA[<h2 id="jsx란">JSX란?</h2>

<blockquote style="margin: 2rem 0px;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1rem 1rem 1rem 2rem;
    color: #ECECEC;">
  <p>- JavaScript XML의 약자로 자바스크립트에서 XML을 추가한 확장형 문법입니다. </p>
  <p>- 자바스크립트에서 HTML 문법을 사용할 수 있습니다. </p>
  <p>- 코드의 가독성과 유지보수 측면에서 이점이 많습니다.</p>
</blockquote>

<p><span style="font-weight: bold">참고 -</span>
<a style="color: dodgerblue" href="https://ko.reactjs.org/docs/introducing-jsx.html" target="_blank" rel="noopener noreferrer">React 공식 홈페이지(JSX 소개)</a>
<br /><br /><br /></p>

<h2 id="작성방법">작성방법</h2>

<p><br /></p>

<h3 id="1-반드시-부모-요소는-한개의-태그로-감싸져-있어야-합니다">1. 반드시 부모 요소는 한개의 태그로 감싸져 있어야 합니다.</h3>

<p><img style="margin: 1rem auto 1rem 0;" width="235" alt="스크린샷 2022-12-04 오후 6 10 57" src="https://user-images.githubusercontent.com/76745621/205483009-0e1dea1d-a5c5-4b5a-a199-5bc348babe1e.png" />
<br /></p>
<blockquote style="margin: 1rem 0px;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1rem 1rem 1rem 2rem;
    color: #ECECEC;">
  <p><a style="color: dodgerblue" href="https://ko.reactjs.org/docs/faq-internals.html#gatsby-focus-wrapper" target="_blank" rel="noopener noreferrer">Virtual DOM</a> 에서 컴포넌트 변화를 효율적으로 감지하여 비교할수 있도록
컴포넌트 내부는 하나의DOM트리로 구성되어 있어야 합니다. </p>
</blockquote>
<p><br /><br /><br /></p>

<h3 id="2-자바스크립트-표현식-작성을-위해서---로-감싸야-합니다">2. 자바스크립트 표현식 작성을 위해서 { } 로 감싸야 합니다.</h3>

<p><img style="margin: 1rem auto 1rem 0;" width="488" alt="스크린샷 2022-12-04 오후 7 21 42" src="https://user-images.githubusercontent.com/76745621/205487384-5caaa382-8514-4ece-9216-e450999e7bdb.png" />
<br /><br /><br /></p>

<h3 id="3-삼항연산자를-활용해-조건부-렌더링을-할-수-있습니다">3. 삼항연산자를 활용해 조건부 렌더링을 할 수 있습니다.</h3>

<p><img style="margin: 1rem auto 1rem 0;" width="488" alt="스크린샷 2022-12-04 오후 7 21 42" src="https://user-images.githubusercontent.com/76745621/205485535-7a800b0f-0e15-47fb-a77e-ead1b5104ed2.png" />
<br /></p>
<blockquote style="margin: 1rem 0px;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1rem 1rem 1rem 2rem;
    color: #ECECEC;">
  <p>if 구문과 for 루프는 JavaScript 표현식이 아니기 때문에 JSX 내부 자바스크립트 표현식에서는 사용할 수 없고 삼항연산자(조건부 연산자)를 사용합니다.</p>
</blockquote>
<p><br /><br /><br /></p>

<h3 id="4-and-연산자를-이용한-조건부-렌더링을-할-수-있습니다">4. AND 연산자를 이용한 조건부 렌더링을 할 수 있습니다.</h3>

<p><img style="margin: 1rem auto 1rem 0;" width="317" alt="스크린샷 2022-12-04 오후 7 39 36" src="https://user-images.githubusercontent.com/76745621/205486163-dded3ee0-6023-4e5f-a439-f8f0e84b3652.png" />
<br /></p>
<blockquote style="margin: 1rem 0px;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1rem 1rem 1rem 2rem;
    color: #ECECEC;">
  <p>특정조건을 만족할때만 내용을 보여주고, 만족하지 않을때는 렌더링 하지 않는 경우에 사용합니다.</p>
</blockquote>
<p><br /><br /><br /></p>

<h3 id="5-class정의시-class가-아닌-classname을-사용해야-합니다">5. class정의시 class가 아닌 className을 사용해야 합니다.</h3>

<p><img style="margin: 1rem auto 1rem 0;" width="347" alt="스크린샷 2022-12-04 오후 7 56 10" src="https://user-images.githubusercontent.com/76745621/205486750-06c4ff6b-079c-4b7f-93b8-16b17ce9b850.png" />
<br /></p>
<blockquote style="margin: 1rem 0px;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1rem 1rem 1rem 2rem;
    color: #ECECEC;">
  <p>JSX는 HTML보다는 JavaScript에 가깝기 때문에, React DOM은 HTML 어트리뷰트 이름 대신 camelCase 프로퍼티 명명 규칙을 사용합니다.</p>
</blockquote>
<p><br /><br /><br /><br /></p>

<h2 id="후기">후기</h2>

<blockquote style="margin: 1rem 0px;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1rem 1rem 1rem 2rem;
    color: #ECECEC;">
  <p>꼭 JSX문법을 사용하지 않아도 된다고는 하지만 리엑트에서도 공식적으로 사용 권장을 희망하고 있고 JSX문법을 사용한 코드와 사용하지 않은 코드를 비교해보면 가독성 측면에서 정말 차이가 많이 나는걸 학습하면서 직접적으로 확인 할 수 있었습니다.</p>
</blockquote>]]></content><author><name>Junghoo</name></author><category term="React" /><category term="JSX" /><summary type="html"><![CDATA[React에서 사용하는 JSX 문법이란?]]></summary></entry><entry><title type="html">Type Assertion (TS2531오류)</title><link href="/jekyll-theme-yat/typescript/2022/11/20/post13.html" rel="alternate" type="text/html" title="Type Assertion (TS2531오류)" /><published>2022-11-20T00:00:00+00:00</published><updated>2022-11-20T00:00:00+00:00</updated><id>/jekyll-theme-yat/typescript/2022/11/20/post13</id><content type="html" xml:base="/jekyll-theme-yat/typescript/2022/11/20/post13.html"><![CDATA[<p>타입스크립트에서는 DOM을 직접적으로 다룰 때 타입을 지정해주지 않으면 오류가 빈번하게 발생합니다. 이때 타입 단언을 통해서 as로 정확하게 타입을 단언해 준다면 비로소 DOM API를 조작할수 있게 됩니다.</p>
<p><br /><br /></p>

<h2 id="타입단언이란">타입단언이란?</h2>

<blockquote style="margin: 2rem 0px;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1rem 1rem 1rem 2rem;
    color: #ECECEC;">
  <p>- 개발자가 해당 타입에 대해 확신이 있을 때 사용하는 타입 지정 방식입니다.</p>
  <p>- value as Type 문법을 사용해 원하는 임의의 타입을 값에 할당할 수 있습니다. </p>
</blockquote>
<p>타입스크립트는 일반적으로 타입 추론을 통해 작성한 코드의 타입을 추론하게 되는데 이때 좀 더 엄격하게 타입 검사를 하는 경우에는 타입을 명확하게 지정해주어야 합니다.</p>
<p><br /><br /></p>

<p></p>

<h3 id="오류-예시">오류 예시</h3>

<p><img style="margin: 0 auto;" width="455" alt="스크린샷 2022-11-21 오전 7 58 14" src="https://user-images.githubusercontent.com/76745621/202931192-13042d13-a3d9-4f5c-910e-90eccc62d713.png" />
<br /><br /></p>
<p>분명 자바스크립트에서는 문제 없이 작동하는 코드인데 오류코드(TS2531)를 내보냈고 이에 대해서 구글링을 한 결과 타입단언을 사용해서 문제를 해결할 수 있었습니다.</p>
<p><br /><br /></p>

<h3 id="해결">해결</h3>

<p><img style="margin: 0 auto;" width="600" alt="스크린샷 2022-11-21 오전 6 19 41" src="https://user-images.githubusercontent.com/76745621/202926839-c41276ac-106b-412d-9fb6-0af8ed3a9de6.png" />
<br /></p>

<blockquote style="margin: 2rem 0px;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1rem 1rem 1rem 2rem;
    color: #ECECEC;">
  <p>HTMLDivElement로 타입 단언을 해준 뒤에는 resultEl 의 타입은 HTMLDivElement로 특정되고 innerText 또한 사용할 수 있게 됩니다.</p>
</blockquote>
<p><br /></p>

<p><br /></p>
<p>참고</p>
<p><a style="color: dodgerblue" href="https://www.typescriptlang.org/docs/handbook/basic-types.html">TypeScript - Type Assertions</a>
<br /><br /><br /></p>

<h3 id="후기">후기</h3>

<blockquote style="margin: 2rem 0px;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1rem 1rem 1rem 2rem;
    color: #ECECEC;">
  <p>너무 무분별하게 타입추론을 사용하지는 않아야겠습니다.</p>
</blockquote>]]></content><author><name>Junghoo</name></author><category term="TypeScript" /><category term="타입 단언" /><category term="제로베이스 프론트엔드 스쿨" /><summary type="html"><![CDATA[TS2531 오류]]></summary></entry><entry><title type="html">TypeScript (타입스크립트 기본타입)</title><link href="/jekyll-theme-yat/typescript/2022/11/13/post12.html" rel="alternate" type="text/html" title="TypeScript (타입스크립트 기본타입)" /><published>2022-11-13T00:00:00+00:00</published><updated>2022-11-13T00:00:00+00:00</updated><id>/jekyll-theme-yat/typescript/2022/11/13/post12</id><content type="html" xml:base="/jekyll-theme-yat/typescript/2022/11/13/post12.html"><![CDATA[<h2 id="타입스크립트란">타입스크립트란?</h2>

<p>마이크로소프트에서 구현한 JavaScript의 슈퍼셋(Superset) 프로그래밍 언어입니다.<br />
때문에 마이크로소프트에서 개발한 소스 코드 편집기(Visual Studio Code)에서도 기본적으로 TypeScript를 지원합니다. </p>
<p><br /><br /></p>

<h3 id="왜-타입스크립트를-사용해야-할까">왜 타입스크립트를 사용해야 할까?</h3>

<p><br />
<img style="margin: 0 auto;" width="700px" alt="스크린샷 2022-11-13 오후 11 13 58" src="https://user-images.githubusercontent.com/76745621/201526368-9ed6fbc3-e665-4b7c-bea7-b0b204609787.png" />
<br /></p>
<p><a style="color: dodgerblue" href="https://npmtrends.com/">npm trends</a> 라는 사이트에서 최근 사용되는 언어 패키지들의 사용량과 인기를 확인할 수 있는데 타입스크립트의 인기가 매우 높은걸 확인 할 수 있습니다.</p>
<p>그렇다면 이러한 타입스크립트를 사용했을 때 이점은 무엇이 있을까요?</p>

<blockquote style="margin: 2rem 0px;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1rem 1rem 1rem 2rem;
    color: #ECECEC;">
  <p>1. 컴파일 시 사전에 에러를 잡을 수가 있습니다.</p>
  <p>2. 타입을 미리 결정하기 때문에 기계가 할 일을 덜어 실행 속도가 매우 빠릅니다.</p>
  <p>3. 다른 사람이 코드를 읽을 경우 타입이 어떤 것인지 짐작할 수 있어 협업에 있어 용이합니다.</p>
</blockquote>

<p><br /><br /></p>

<p>타입스크립트는 아래와 같이 미리 지정한 타입과 다른 값이 매개변수 값으로 들어올 경우 미리 사전에 알려줍니다.</p>
<p><img style="margin: 1rem auto 0" width="550" alt="스크린샷 2022-11-13 오후 11 38 15" src="https://user-images.githubusercontent.com/76745621/201527508-b0f68bed-eed3-49d2-84af-64d5be6b1b97.png" />
<br /><br /></p>

<h2 id="타입스크립트의-기본-타입">타입스크립트의 기본 타입</h2>

<p>타입스크립트는 타입을 미리 정할 수 있다고 했는데 이러한 타입의 종류는 아래와 같습니다.</p>
<p><br /></p>

<h3 id="1-boolean-타입">1. Boolean 타입</h3>

<p><img style="margin: 1rem 0px;" width="242" alt="스크린샷 2022-11-14 오전 12 30 13" src="https://user-images.githubusercontent.com/76745621/201529955-5ca0b3e8-c993-4796-bdd5-1bff5b135348.png" /></p>
<blockquote style="margin: 2rem 0px;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1rem 1rem 1rem 2rem;
    color: #ECECEC;">
  <p>값을 호출하는 단순한 true/false 값 boolean입니다.</p>
</blockquote>

<p><br /></p>

<h3 id="2-number-타입">2. Number 타입</h3>

<p><img style="margin: 1rem 0px;" width="194" alt="스크린샷 2022-11-14 오전 12 29 11" src="https://user-images.githubusercontent.com/76745621/201529858-8e63a0a2-f2f4-4ed1-9622-eb0d574723a1.png" /></p>
<blockquote style="margin: 2rem 0px;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1rem 1rem 1rem 2rem;
    color: #ECECEC;">
  <p>- 숫자형 타입 number입니다.</p>
</blockquote>
<p><br /></p>

<h3 id="3-string-타입">3. String 타입</h3>

<p><img style="margin: 1rem 0px;" width="202" alt="스크린샷 2022-11-14 오전 12 39 22" src="https://user-images.githubusercontent.com/76745621/201530369-a81eb143-6c31-47a4-adbe-b1ab0f1dc1cd.png" /></p>
<blockquote style="margin: 2rem 0px;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1rem 1rem 1rem 2rem;
    color: #ECECEC;">
  <p>- 문자형 타입 string입니다.</p>
  <p>- 템플릿 문자열을 사용할 수도 있습니다.</p>
</blockquote>
<p><br /></p>

<h3 id="4-array-타입">4. Array 타입</h3>

<p><img style="margin: 1rem 0px;" width="286" alt="스크린샷 2022-11-14 오전 12 43 52" src="https://user-images.githubusercontent.com/76745621/201530568-fd1426a0-6726-46ec-8231-24973ef1ed77.png" /></p>
<blockquote style="margin: 2rem 0px;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1rem 1rem 1rem 2rem;
    color: #ECECEC;">
  <p>- 배열 타입 array입니다.</p>
</blockquote>
<p><br /></p>

<h3 id="5-tuple-타입">5. Tuple 타입</h3>

<p><img style="margin: 1rem 0px;" width="223" alt="스크린샷 2022-11-14 오전 12 48 04" src="https://user-images.githubusercontent.com/76745621/201530782-77d3f657-417a-40af-bbe1-5fc20963d3bf.png" /></p>
<blockquote style="margin: 2rem 0px;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1rem 1rem 1rem 2rem;
    color: #ECECEC;">
  <p>- 동일할 필요는 없는 고정된 수의 요소가 있는 배열을 표현할 수 있습니다</p>
</blockquote>
<p><br /></p>

<h3 id="6-void-타입">6. Void 타입</h3>

<p><img style="margin: 1rem 0px;" width="288" alt="스크린샷 2022-11-14 오전 12 56 08" src="https://user-images.githubusercontent.com/76745621/201531166-c9d0d93c-a8dc-4eff-91f2-ec109e7524fd.png" /></p>
<blockquote style="margin: 2rem 0px;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1rem 1rem 1rem 2rem;
    color: #ECECEC;">
  <p>- 값을 반환하지 않는 함수의 반환 유형으로 볼 수 있습니다</p>
</blockquote>
<p><br /></p>

<h3 id="7-null-undefined-타입">7. Null, Undefined 타입</h3>

<p><img style="margin: 1rem 0px;" width="272" alt="스크린샷 2022-11-14 오전 1 05 37" src="https://user-images.githubusercontent.com/76745621/201531643-9c6a274d-686b-479a-b2c6-e2fe15d7deeb.png" /></p>
<blockquote style="margin: 2rem 0px;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1rem 1rem 1rem 2rem;
    color: #ECECEC;">
  <p>- JavaScript에서와 마찬가지로 고유의 특별한 타입으로 인정합니다.</p>
  <p>- 이외에 void, never와 같이 더 세밀한 타입도 제공합니다.</p>
  <p>- strictNullChecks가 핵심</p>
</blockquote>
<p><br /></p>

<h3 id="8-object-타입">8. Object 타입</h3>

<p><img style="margin: 1rem 0px;" width="439" alt="스크린샷 2022-11-14 오전 1 18 13" src="https://user-images.githubusercontent.com/76745621/201532247-d5956eca-046a-488e-ac46-df646a9b0f61.png" /></p>
<blockquote style="margin: 2rem 0px;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1rem 1rem 1rem 2rem;
    color: #ECECEC;">
  <p>- JavaScript에서 사용하는 객체형 타입 Object 입니다.</p>
  <p>- 하지만 일반적으로 위 이미지와 같이 사용하지 않고 Type Alias를 활용하여 사용합니다.</p>
</blockquote>
<p><br /></p>

<p><br /></p>
<p>추가적인 타입스크립트 타입에 대한 정보는 아래 링크를 통해 남기겠습니다.</p>
<p><a style="color: dodgerblue" href="https://www.typescriptlang.org/docs/handbook/basic-types.html">TypeScript - 타입 유형</a></p>

<p><br /></p>]]></content><author><name>Junghoo</name></author><category term="TypeScript" /><category term="TypeScript 기본 타입" /><category term="제로베이스 프론트엔드 스쿨" /><summary type="html"><![CDATA[TypeScript의 타입과 작성방법]]></summary></entry><entry><title type="html">DOM이란 무엇일까</title><link href="/jekyll-theme-yat/javascript/2022/11/06/post11.html" rel="alternate" type="text/html" title="DOM이란 무엇일까" /><published>2022-11-06T00:00:00+00:00</published><updated>2022-11-06T00:00:00+00:00</updated><id>/jekyll-theme-yat/javascript/2022/11/06/post11</id><content type="html" xml:base="/jekyll-theme-yat/javascript/2022/11/06/post11.html"><![CDATA[<pre>웹브라우저를 공부하면서 흔히 DOM이란 단어를 많이 접하게 됩니다.
그렇다면 이 DOM이란건 도대체 무엇일까요?  
</pre>
<p><br /></p>

<h2 id="dom이란">DOM이란?</h2>

<blockquote style="margin: 2rem 0px;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1rem 1rem 1rem 2rem;
    color: #ECECEC;">
  <p>DOM이란 'Document Object Model' 의 약자입니다. 이를 직역하면 '문서 객체 모델'인데요.</p>
  <p> 브라우저는 우리가 HTML(HyperText Markup Language)로 작성한 문서의 내용들을 읽고 이를 해석하는 과정에서 HTML 요소들을 Tree형태로 구조화하게 됩니다.</p>
  <p>그리고 이렇게 구조화된 정보를 통해 브라우저 화면에 우리가 작성했던 HTML 정보들이 보여지게 되는데 이렇게 Tree로 구조화된 정보들을 바로 DOM이라고 부릅니다.</p>
</blockquote>
<p><br /><br /></p>

<h2 id="dom의-구조-모습">DOM의 구조 모습</h2>

<p><img style="margin: 2rem auto 0" width="434" alt="스크린샷 2022-11-06 오후 6 26 27" src="https://user-images.githubusercontent.com/76745621/200169360-9a6b3690-620d-4601-b5f8-c837c192e5c0.png" />
<br />
<a style="color: dodgerblue" href="https://ko.wikipedia.org/wiki/%EB%AC%B8%EC%84%9C_%EA%B0%9D%EC%B2%B4_%EB%AA%A8%EB%8D%B8">(참조: 문서 객체 모델 - 위키백과)</a>
<br /><br /></p>
<blockquote style="margin: 2rem 0px;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1rem 1rem 1rem 2rem;
    color: #ECECEC;">
  <p>브라우저에서는 HTML문서를 파싱(Parsing)하여 Tree구조 형태의 DOM을 만들게 되는데요.</p>
  <p>이때 모든 요소, 속성, 텍스트 등의 정보들을 참조하고 요소의 중첩관계는 객체의 트리로 구조화하여 부자관계를 표현합니다.</p>
  <p>각 부자 관계를 가지는 요소들을 이어주는 것을 node라고 하는데 더이상의 상위 요소가 없는 요소를 최상위 노드, 즉 root node 라고 합니다.</p>
</blockquote>
<p><br /><br /></p>

<h2 id="개발자도구로-dom-tree-확인">개발자도구로 DOM Tree 확인</h2>

<p><br /></p>
<p>브라우저에서 제공하는 개발자도구(Developer Tools)를 통해서 DOM Tree를 쉽게 확인 할 수 있습니다.</p>
<p>MAC 운영체제를 사용하는 경우에는 option + command + i</p>
<p>Windows 운영체제를 사용하는 경우에는 F12</p>
<p><br />
<img style="margin: 0 auto" width="546" alt="스크린샷 2022-11-06 오후 9 48 18" src="https://user-images.githubusercontent.com/76745621/200172745-a95157ef-b955-47a9-b435-f41ab43a60ec.png" />
<br /><br /></p>

<blockquote style="margin: 2rem 0px;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1rem 1rem 1rem 2rem;
    color: #ECECEC;">
  
  <p>DOM 트리를 기반으로 브라우저에서 랜더링 된 요소(Elements)를 확인할 수 있고 요소의 속성을 직접 제어할 수도 있습니다.</p>
</blockquote>

<p><br /><br /></p>

<p>하지만 개발자도구를 통해서 DOM을 직접적으로 제어해도 브라우저가 새로고침되면 변경된 사항들은 다시 원래대로 되돌아가게 됩니다.</p>
<p>브라우저는 우리가 작성했던 HTML 파일을 기반으로 랜더링 되어져 있기 때문인데요.</p>
<p>그렇다면 어떻게 해야 DOM을 조작하고 그 조작한 내용들이 계속 유지가 될 수 있게 할 수 있을까요?</p>
<p>바로 JavaScript에서 제공하는 DOM API를 활용하는 방법이 있습니다.</p>
<p><br /><br /></p>

<h3 id="dom-api란">DOM API란?</h3>

<blockquote style="margin: 2rem 0px;
    max-width: 508px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1rem 1rem 1rem 2rem;
    color: #ECECEC;">
  <p>간단하게 자바스크립트에서 HTML을 제어하는 여러가지 명령들이라고 생각하면 됩니다.</p>
</blockquote>

<p><br /><br /></p>

<h3 id="대표적인-dom-api-method">대표적인 DOM API Method</h3>

<blockquote style="margin: 2rem 0px;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1rem 1rem 1rem 2rem;
    color: #ECECEC;">
      <p>getElementById( ) - 매개변수로 받은 값을 id로 가진 element를 반환.</p>
      <p>getElementByClassName( ) - 매개변수로 받은 값을 class 이름으로 가진 element를 반환.</p>
      <p>querySelector( ) - 매개변수로 특정한 CSS 지시자를 받는데 document 내에서 이 CSS 지시자와 일치한
첫번째 element를 반환.</p>
  <p>querySelectorAll( ) - 일치하는 모든 element들을 반환.</p>
  <p>createElement( ) - 새로운 element node를 생성.</p>
</blockquote>

<p><br /></p>

<p>위에 소개 된 DOM API Method 외 DOM API의 종류는 너무나도 많은데 더 추가적인건 링크를 남겨 놓겠습니다.</p>

<p><a style="color: dodgerblue" href="https://developer.mozilla.org/ko/docs/Web/API/Document_Object_Model/Introduction#dom_%EC%97%90_%EC%96%B4%EB%96%BB%EA%B2%8C_%EC%A0%91%EA%B7%BC%ED%95%A0_%EC%88%98_%EC%9E%88%EB%8A%94%EA%B0%80">MDN - DOM 소개</a></p>

<p><br /><br /></p>

<h2 id="후기">후기</h2>

<blockquote style="margin: 2rem 0px;
    max-width: 768px;
    word-break: keep-all;
    border-left: 4px solid #63E6BE;
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
    background: #1E1E1E;
    padding: 1rem 1rem 1rem 2rem;
    color: #ECECEC;">
  <p>DOM에 대한 이번 학습을 통해서 왜 자바스크립트를 배우면서 DOM에 대해서 알고 있어야 하는지에 대해 한 번더 생각할 수 있었고 브라우저가 화면에 출력되는 과정들에 대해서 이해하는데 많은 도움이 되었습니다.</p>
</blockquote>]]></content><author><name>Junghoo</name></author><category term="JavaScript" /><category term="JavaScript" /><category term="제로베이스 프론트엔드 스쿨" /><summary type="html"><![CDATA[DOM(Document Object Model)]]></summary></entry></feed>